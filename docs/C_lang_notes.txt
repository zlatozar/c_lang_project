[STYLE] All macros and constants in caps: MAX_BUFFER_SIZE, TRACKING_ID_PREFIX.

[STYLE] Struct names and typedef's in camelcase: GtkWidget, TrackingOrder.

[STYLE] Functions that operate on structs: GtkWidget_show(), TrackingOrder_process().

[TIP] Don't use global variables. They are evil.

[STYLE] Functions that shouldn't be called directly, or have obscure uses, or
        whatever must start with one or more underscores at the beginning:
        _refrobnicate_data_tables(), _destroy_cache().

[STYLE] Initialize variables in there declarations.

[LANG] String constant is an array of characters. The internal representation of
       a string has a null character '\0' at the end, so physical storage
       required is one more than the number of characters. 'strlen(s)' excludes
       terminal '\0'.

[LANG] External and static variables are initialized to zero by default.

[STYLE] Use 'const' to show that you are not going to change value passed by
        reference, especially in functions parameters: int strlen(const char[])

[LANG] Precedence of '&&' is higher than that of '||'.

[TIP] Specify 'signed' or 'unsigned' if non-character data is to be stored
      in 'char' variables.

[LANG] Logical operations in C are 0 or 1. '!' operator inverts them.
       Everything that is not 0/NULL is true: assert(!"Impossible")

[LANG] 'floats' are not automatically converted to 'double'.

[TIP] The main reason for using 'float' is to save storage in a large arrays.

[LANG] x = f() + g() C do not define which function will be evaluated first.
       It is the same for function arguments.

[LANG] Non-zero means true: assert("Pass")

[STYLE] When there is no initialization and re-initialization prefer 'while'.

[STYLE] Irrelevant details could be buried in the functions. In this way the
        chance of unwanted interactions is minimized and the pieces may even
        be useful in other programs.

[TIP] Always limit C programs input with upper bounds.

[TIP] C programs are flat so functions are visible to any part of the entire
      program. Make functions kind of private as declare them 'static'

[STYLE] Stick to onion architecture - layer can "see" only first below it.

[TIP] The structure of the project is very important - it explains the
      visibility. Do not make tricks with compilation order and keep it
      consistent.

[LANG] Functions can't be defined within functions so we can't do real
       functional programming.

[LANG] For external and static variables, the initializer must be a constant
       expression; the initialization is done once, conceptually before the
       program begins execution. Same in Java.

[LANG] If there are fewer initializers for an array than the number specified,
       the missing elements will be zero for external, static, and automatic
       variables.

[TIP] Do increment as usual i = i + 1; and when function is correct make it
      prefix or postfix.

[TIP] You can't nest functions but if it is needed definition should be used:
      void reverse(char[] str) {
          void reverser(char[] str, int i, int len);
          reverser(str, 0, strlen(str));
      }
      void reverser(char[] str, int i, int len) {
          ...
      }

[STYLE] Use #include "foo.h" for your modules and #include <..> for standard.

[TIP] Prefer this type of declaration int *p_value;
      Is a mnemonic - what p_value points to has type int.

[STYLE] The single most important rule when writing code is this: check the
        surrounding code and try to imitate it. As a maintainer it is dismaying
        to receive a patch that is obviously in a different coding style to the
        surrounding code. This is disrespectful, like someone tromping into a
        spotlessly-clean house with muddy shoes. If there is already written
        code and you are patching it, keep its current style consistent even if
        it is not your favorite style.

[LANG]    (*p_value)++  // to increment value that p_value points to
       The parentheses are necessary; without them, the expression would
       increment 'p_value' instead of what it points to, because unary operators
       like * and ++ associate right to left.

[LANG] In some cases it is better to look at &x as anonymous pointer rather
       than address of x. Example: void swap(&x, &y) or int *ip; ip = &a[0];

[TIP] It is common for functions to use passed pointer as "wire" to set
      values as function side-effect.

[LANG] &a[i] and a+i are identical: a+i is the address of the i-th element
       beyond a. a[i] C language converts it to *(a + i) - pointer and offset.

[LANG] char s[]; and char *s; are equivalent. Prefer latter. When an array name
       is passed to a function, the function can at its convenience believe
       that it has been handed either an array or a pointer, and manipulate it
       accordingly.

[LANG] C guarantees that zero is never a valid address for data, so a return
       value of zero can be used to signal an abnormal event, in this case, no
       space. Pointers and integers are not interchangeable. Zero is the sole
       exception: the constant zero may be assigned to a pointer, and a pointer
       may be compared with the constant zero. Check pointer with NULL.

[LANG] External and static variables are initialized to zero be default.

[LANG] The main reason for using float is to save storage in large arrays.

[LANG] The input or output, regardless of where it originates or where it goes to,
       is dealt with as stream of characters.

[LANG] In C, any assignment, is an expression and returns a value, which is the
       value of the left hand side after the assignment. That's why it is
       possible to write: while (*s++ = *t++) {;}, if s and t are pointers to
       string. At the end assignment will return '\0' (same as 0) and the cycle
       will exit.

[TIP] Programs should act intelligently when given zero-length input.

[LANG] By definition, chars are just small integers, so char variables and
       constants are identical to ints in arithmetic expressions.

[TIP] Prefer small functions. With properly designed functions, it is possible
      to ignore how a job is done; knowing what is done is sufficient.

[TIP] C language is like a Latin - gives you the base, everything else are rules,
      conventions, project structure, autotools magic and proper macros.

[LANG] Since main is a function like any other, it may return a value to its
       caller, which is in effect the environment in which the program was
       executed. Typically, a return value of zero implies normal termination -
       NO ERRORS; non-zero values signal unusual or erroneous termination
       conditions - WITH ERRORS.

[LANG] int is the default return type.

[LANG] "Definition" refers to the place where the variable is created or
       assigned storage; "declaration" refers to places where the nature of the
       variable is stated but no storage is allocated usually in header files.

[LANG] The first name in an enum has value 0, the next 1, and so on, unless
       explicit values are specified.

[TIP] When your build tool do compilation be sure that will recompile when
      an included file is changed.

[TIP] In pointer arithmetic look at the types as a size of memory.

[TIP] You can use pointer arithmetic only when have the starting point and
      a way to calculate offset.

[LANG] malloc() use stack in it's implementation so we have to apply free() in
       reverse order.

[LANG] *--p; decrements p before fetching the value that p points to.
       Examples:   *p++ = val;   /* push value onto stack */
                   val = *--p;   /* pop top of the stack into val */

[TRICK] The syntax a[i] is equivalent to *(a + i). Thus it is valid to say 5[a]
        to get at the 5th element of a.

[TIP] Pointer-arithmetic says that given a pointer p and an integer i, p + i the
      pointer p advanced by i * sizeof(*p) bytes

[TIP] The [] operator is defined on pointers, not arrays. In particular, it's
      defined in terms of pointer arithmetic and pointer dereference.

[TIP] A pointer is abstractly a tuple (start, length, offset) with the condition
      that 0 <= offset <= length. Pointer arithmetic is essentially lifted
      arithmetic on the offset, with the caveat that if the result of the
      operation violates the pointer condition, it is an undefined value.
      Dereferencing a pointer adds an additional constraint that offset < length.

[TIP] POSIX is a superset of the standard C library, and it's important to note
      that it defers to it. If C and POSIX is ever in conflict, C wins.

[TIP] Mocking is strongly connected with the ability of dependency injection.
      Here a technique from functional programming could be used - replace all
      changeable steps in a workflow with functions. During testing you can
      pass fake/mocked one.

[TIP] Dependencies injection could be reached using - 'Dependency rejection' and
      'Dependency parameterization'

[TIP] Header files are sometimes also an appropriate location for ​struct​
      definitions. If other parts of the program will make direct use of the
      ​struct​ fields, then the definition of that ​struct necessarily must appear
      in the header file. If that is not the case, it is better to hide the
      ​struct definition in a .​c​ file. A common practice is to use a ​typedef​
      statement in a header file to declare a type for other parts of the
      program, and hide the definition of that type.

[TIP] Having a long ​main​ function indicates a lack of abstraction, meaning that
      your code has not been sufficiently split into logical, smaller functions.

[TIP]           int a[10][20];
                int *b[10];     // lazy initialization
      The definition of b only allocates 10 pointers and does not initialize
      them; initialization must be done explicitly, either statically or with
      code. The important advantage of the pointer array is that the rows of
      the array may be of different lengths.

[TIP] During development wishful thinking can be used.
      At the beginning of the file declare functions that you with to have
      and continue to work on the algorithm. In this way also compilation
      will be fast. When definitions are added or imported you can safely
      remove them.

[LANG] (*++argv)[0]; because [] binds tighter than * and ++, the parentheses
       are necessary. By the way **++argv; is an alternate valid form.

[LANG] In expressions '[]' is with highest priority following by '->'. After
       them are '++' and then '--', but for them keep in mind if they are used
       as prefix or postfix operators. At last is '*' but it has some kind of
       highest priority from '++' and '--' if they are used as postfix
       operators(e.g. *p++)

[TIP] In C language, structures can be viewed as an some kind of memory template
      or model. Using it you can easily find out its parts or save at particular
      place. Using it the memory becomes a city with documented infrastructure.

[TIP] Glue C program during compilation through include/module/header_file.h.

[TIP] If you constantly ask for a particular field in a struct automate access
      with a macro e.g. #define OFFSET(s) (((struct symtab *) s) -> s_offset)

[TIP] Structures saves the state of the program in an organized way.

[TIP] Start writing program(or it's fragments) as first define 'in structures'
      and 'out structures' then concentrate on actions.

[LANG] Struct declaration defines as a type (using typedef)

[LANG] A structure declaration that is not followed by a list of variables
       reserves no storage; it merely describes a template or the shape of a
       structure.

[LANG] Structures may not be compared. C provides no language facilities to do
       this - you have to do it yourself and compare each structure member by
       member.

[LANG] The only legal operations on a structure are copying it or assigning to
       it as a unit, taking its address with &, and accessing its members. Copy
       and assignment include passing arguments to functions and returning
       values from functions as well.

[LANG] If you have to write functions to manipulate structure There are at
       least three possible approaches: pass components separately, pass an
       entire structure, or pass a pointer to it.

[TIP] If a large structure is to be passed to a function, it is generally more
      efficient to pass a pointer than to copy the whole structure.

[STYLE] Always use '->' to access structure fields.

[LANG] Note that the typedef name doesn't become visible until the end of the
       declaration. If the structure contains a pointer to itself, you have use the
       struct version to refer to it:
               typedef struct node {
                   int data;
                   struct node *next; /* can't use just "node *next" here */
               } node;

[LANG] A typedef, in spite of the name, does not define a new type; it merely
       creates a new name for an existing type.

[LANG] It is common idiom to use both typedef and struct:
              typedef struct S {
                  int x;
              } S;        // same name as struct tag!
       This gives you the convenience of the more concise typedef name but still
       allows you to use the full struct name if you need.

[LANG]       typedef struct S {
                 int x;
             } S;
       Could be rewritten as:
             struct S {  // define the identifier S within the struct name space
                 int x;
             };
             typedef struct S S;
       Last line adds a type alias S in the global name space and thus allows
       you to just write:
             void f(S arg); // struct keyword no longer needed

[LANG]       struct foo {
                 int n;
             };
       The name 'foo' is a tag; it's meaningful only when it's immediately
       preceded by the struct keyword.

[LANG]       struct foo {
                 int n;
             };
       Giving the struct a name (i.e. struct foo) also enables you to provide
       forward declarations of the struct. So in some other file, you could
       write:
            struct foo;
            void doit(struct foo *ptr);
       without having to have access to the definition use just the name.

[LANG] The following code creates an anonymous struct with the alias MyStruct:
            typedef struct {
                int one;
                int two;
            } MyStruct;
       You can't refer it without the alias because you don't specify an
       identifier for the structure. Forward declaration also will not work:
            struct MyStruct; // forward declaration in another file fails

[LANG] Structure is a data type. You don't give values to a data type. You give
       values to instances of data types. Here is an example:
            struct my_struct {
                int id;
            } MyStruct_default = {3};
            typedef struct my_struct MyStruct;
            // then it is possible to initialize every instance
            MyStruct mInstance = MyStruct_default;

[LANG] The size of the array is completely determined at compile time.

[LANG] A sizeof can not be used in a #if line, because the preprocessor does not
       parse type names. But the expression in the #def ine is not evaluated by
       the preprocessor, so the code here is legal.

[TIP] To be testing/emulating/mocking easier use some of following techniques:
          - Pass around functions (and use partial application) - this is simple
            functional approach that will work unless you need to pass around
            too many parameters.
          - Use an "interpreter" pattern where the computation is written in an
            (embedded) domain specific language that describes what computations
            and what I/O needs to be done (without actually doing it). Then you
            can interpret the DSL differently in real and test mode.
          - Use pipelines for each workflow. Write a "Lego blocks" that could be
            combined in various ways - Dependency rejection
          - During development plan not only production but also and testing
            workflow.

[TRICK] C treats strings as arrays of characters conventionally terminated by a
        marker. All following statements are equivalent:
             for (p = str; *p; p++)
             for (p = str; *p != '\0'; p++)
             for (p = str; *p != 0; p++)
             for (p = str; p[0] != '\0'; p++)

[LANG] Addition of two pointer is illegal but subtraction is not! If you want to
       calculate middle of a string using pointers:
             mid = (low + high) / 2         // WRONG
             mid = low + (high - low) / 2   // Correct

[TIP] When use pointer arithmetic you work with relative addresses so it is very
      important to set the beginning and then calculate offset to find the right
      place. Here is an example:
           for (p = keytab; p < keytab + NKEYS; p++) {...
      'keytab' is the first element in an array, so the pointer p should be set
      to point it. It follows that the last element address is the beginning
      plus the size of the array which forms offset: keytab + NKEYS

[TIP] When calculate space to save a new string do not forget to include in
      calculation '\0':
           (char *) malloc(strlen(s) + 1);  // +1 for '\0'

[TIP] When write a function that do some operation on a structure always as
      first argument pass the structure:
          struct tnode *addtree(struct tnode *p, char *s)
      this is the convention in many functional languages.

[TIP]     struct tnode {
              char *word;
              int count;
              struct tnode *left;   // pointer to the left
              struct tnode *right;
          };
      Tree is recursive structure that's why tnode is a tree
      and tree is tnode. In this way you can pass a tree and
      the function could return "grown tree" e.g
          struct tnode *root;
          ....
          root = addtreex(root, word, num, &found);

[TRACK]        do { ... } while(0);
        idiom ensures that the code acts like a statement - function call;

[TIP] The reading time for programs is much more than the writing time.
      Make reading easy to do.

[TIP] Each function should do only one task, but do it well.

[STYLE] Each function should hide something.

[TIP] Program testing can be used to show the presence of bugs, but never their
      absence.

[TIP] Most programs spend 90 percent of their time doing 10 percent of their
      instructions. Find this 10 percent, and concentrate your efforts for
      efficiency there.

[TIP] Know your problem. Give precise preconditions and postconditions for each
      function.

[TIP] Keep your algorithms as simple as you can. When in doubt, choose the
      simple way.

[TIP] Consider time and space trade-offs in deciding on your algorithm.

[TIP] Never be afraid to start over. Next time it may be both shorter and
      easier. Starting afresh is usually easier than patching an old program.

[TIP] Be sure you understand your problem completely. If you must change its
      terms, explain exactly what you have done.

[TIP] Always plan to build a prototype and throw it away. You'll do so whether
      you plan to or not.

[TIP] Let your data structure your program. Refine your algorithms and data
      structures at the same time.

[TIP] Once your data are fully structured, your algorithms should almost write
      themselves.

[TIP] A sentinel is an extra item added to one end of a list to ensure that a
      loop will terminate without having to include a separate check.

[TIP] During the traversal of any tree, vertices are added to or deleted from
      the path back to the root in the fashion of a stack. Given any stack,
      conversely, a tree can be drawn to portray the life history of the stack,
      as items are added to or deleted from it.

[TIP] Efforts should be concentrated in the design; never design while coding.
      Time spent producing a careful, thorough design will be more than made
      up for with savings in the later phases of a project. The program
      design should accurately address the needs of the problem. Pseudo-code
      should be used to create high-level outlines of the algorithms. Whenever
      possible, the algorithms should be proven logically and mathematically
      correct.

[STYLE] Programs should be divided into reasonably small modules. The modules
        should first be tested individually and then their interactions should be
        tested. One of the greatest difficulties of writing large programs is that
        their reliability tends to degrade with their length.

[TIP] Programming should be done in a top-down fashion. Large tasks should
      be divided into manageable subtasks. Starting with a broad abstract
      outline of the components of a task should lead to a specification of the
      highest-level functions and control flow. Always begin with the highest
      levels of abstraction and work toward the lowest.

[STYLE] Do not duplicate code; use functions.

[TIP] Close attention should be paid to communication between functions.
      Parameters that are being passed should be appropriate for the role of the
      subfunction. Sometimes it is appropriate to pass more information than
      appears to be needed if that information might be necessary for an
      alternate implementation of the subfunction, or if it is being used to make
      the subfunction more universal. This enables the same function to be
      called in many places and in many different modules.

[TIP] Invest time now for a long-term payoff. Take the time to do things right
      the first time. Do not be afraid to code several alternatives and then
      choose. Do not be afraid to rewrite code that works, but works poorly
      or is unclear.

[STYLE] Take comments and documentation seriously. Without them, programs
        are impossible to read, use, or maintain.

[TIP] Do not work in a vacuum. Discuss design and coding issues with others.
      It is very helpful to read code written by others and have others read
      yours.

[TIP] Isolate input and output in modules specialized for that purpose. Do not
      make them side effects of modules that do other tasks. They should be
      at the beginning and at the end of your program logic.

[TIP] Above all elsef clarity. Don't be afraid to violate any general principle
      for the sake of clarity.

[STYLE] Avoid global variables. Use functions with parameters instead. When a
        program contains no global variables, one knows that each function
        manipulates only the data that is passed in the form of parameters.

[STYLE] Use abstract data types (ADT) - define types and possible operations
        on them.

[TIP] Write generic/polymorphic functions. Although they often take slightly
      longer to write, they are far more likely to be reusable. This way, a "tool
      box" of routines can be developed over time.

[TIP] Programs should be crash-proof. A well-written program should never
      crash. In particular, it should be able to cope with illegal input.

[STYLE] Use assertions. Assertions are statements placed in a program to test
        that conditions that logically should be met have indeed been met. They
        help to track logic errors during development.

[STYLE] Avoid explicit literals. Explicit literals (character, numeric, and string
        values) make programs hard to modify. Use #define'd symbolic names instead.

[STYLE] C provides great freedom. Use it responsibly. Avoid side effects in
        logical tests. Avoid being overly compact at the expense of clarity.
        Avoid following the "convention" of using truncated cryptic names.

[TIP] Think twice before optimizing. Programming time is a precious resource.
      First consider using a different algorithm altogether. If the program must
      be optimized, profile the code to find out where it is spending its time.
      Remember it is always better to improve an algorithm than tune the clarity
      out of code.

[TIP] The effectiveness of a “modularization” is dependent upon the criteria
      used in dividing the system into modules. A timely reminder that it’s not
      simply about having lots of small modules, a large part of the success or
      otherwise of your system depends on how you choose to divide the system
      into modules in the first place.

[TIP] A program has structure: the set of modules in the system, and the
      connections between them.

[TIP] How to decompose program in a modules? First of all do not decompose a
      system into modules on the basis of a flowchart. We propose instead that
      one begins with a list of difficult design decisions or design decisions
      which are likely to change. Each module is then designed to hide such a
      decision from the others as inject this decisions as dependencies.

[TIP] Additional developers speed up a project significantly only after the
      project has been divided into sub-projects in such a way that separate groups
      can work with little interaction (i.e. spending significantly less time in
      inter-group decisions than in intra-group decisions).

[STYLE] Declare your variables as close as possible to the place where you will
        use them.

[STYLE] Don’t use macros to create your own personal programming language.

[STYLE] Don’t put closing braces more than one screen away from the matching
        opening brace.

[TIP] Do not use global variables instead pass a pointer to local variable
      to the next function e.g. root = addtreex(root, word, num, &found);

[LANG] To ensure that result is not negative use unsigned numbers.

[TIP]     for (ptr = head; ptr != NULL; ptr = ptr->next)
      is the standard idiom for walking along a linked list.

[TRICK] Here is you can organize kind of getters:
             typedef struct {
                 node *front;
                 node *rear;
             } queue;
             #define FRONT(Q) ((Q)->front)
             #define REAR(Q)  ((Q)->rear)

[TIP] Do not forget to use strdup(s) when store string e.g.
           np->defun = strdup(s)
      otherwise a lot of pointer will point to the same.

[LANG] Assignment '=' is with very low priority (right to left associations).

[LANG] typedef is not used only for data structures(struct). You can look on it
       as #define, except that since it is interpreted by the compiler, it can
       cope with textual substitutions that are beyond the capabilities of the
       preprocessor. For example you can make code more readable if you alias
       complex function pointer declarations:
           typedef int (*PFI) (char *, char *);
           PFI strcmp, numcmp;    // IDE will help you to go to the alias

[LANG] Unions are similar to structures, except that a variable can hold data
       for only a single member at any given time - same "structure" for
       different types of data. They are implemented by allocating enough space
       for the largest possible member, and overlaying the members.

[TIP] For unions it is up to the programmer to ensure that the same member is
      used to retrieve the data as was used to store the data. A convenient way of
      doing this is to make a structure containing two fields: the union and a "type"
      field to specify which union member is currently stored.

[LANG] Unions are sum types, structures are product types.

[LANG] The same place regardless of its type this is the purpose of a union -
       a single variable that can legitimately hold any one of several types.

[LANG] A union may only be initialized with a value of the type of its first member.

[TIP] Unions are also sometimes used to implement pseudo-polymorphism in C, by
      giving a structure some tag indicating what type of object it contains, and then
      unioning the possible types together:
           // easier to reuse memory that might be used in different ways
           enum Type { INTS, DOUBLE };
           struct S {
               Type s_type;
               union {
                   int s_ints[2];
                   double s_double;
               };
          };
          ...
          switch(s->s_type) {
              case INTS:    // s->s_ints
              case DOUBLE:  // s->s_double

[LANG] Unions allow data members which are mutually exclusive to share the same memory.
       Following union will take up the space of a single int, rather than 3
       separate int values:
            union {
                int a;
                int b;
                int c;
            } u;

[TIP] Mask usage example:
          enum { KEYWORD=01, EXTERNAL=02, STATIC=04 };
          // turns on the EXTERNAL and STATIC bits in flags
          flags |= EXTERNAL | STATIC;
          // turns them off
          flags &= ~(EXTERNAL | STATIC);
          // is true if both bits are off
          if ((flags & (EXTERNAL | STATIC)) == 0)

[TIP] For reference use: https://en.cppreference.com/w/c

[TIP] When you call malloc(), you specify the amount of memory to allocate. The
      amount of memory actually used is slightly more than this, and includes
      extra information that records (at least) how big the block is. When you
      call free(), it simply looks at the extra information to find out how big
      the block is. That's why you can pass to free() any kind of pointer, even
      (void *).

[TIP] Two goals in developing functions are to make the interfaces as clean as
      possible and to make the source code as readable as possible.

[TIP] Think of the C types as kind of shaped piece of memory that is labeled.
      With them memory became mapped.

[LANG] It would be more correct to say that stdin, stdout, and stderr are "I/O
       streams" rather than files. But the Unix philosophy, as far as I/O is
       concerned, is "everything is a file".

[LANG] A width or precision of printf may be specified at runtime using *, in
       which case the value is computed by converting the next argument (which
       must be an int). For example, to print at most max characters from a
       string s:
             printf("%.*s", max, s);

[TIP] In C every unit test contains various "main methods" - push
      different input and checks if result is correct.

[TIP] Functions that return something that could be interpreted as length
      should return size_t.

[TIP] If you delete something from a data structure then do not forget to
      call free()!

[TIP] struct should include typedef to remove the need to include "struct"
      keyword through the code.

[TIP] typedefs that "hide" complex function pointers should have suffix '_fn'.

[TIP] Forward declaration is a declaration preceeding an actual definition,
      usually for the purpose of being able to reference the declared type
      when the definition is not available. Such type is called incomplete,
      and there are a number of restrictions on its usage. This can be useful
      e.g. to break circular dependencies, or cut down the compilation time.
      For example:
           truct X;               // forward declaration
           void f(struct X*) { }  // usage of the declared, undefined structure
        // void f(struct X) { }         // ILLEGAL
        // struct X x;                  // ILLEGAL
        // int n = sizeof(struct X);    // ILLEGAL
        // Later, or somewhere else altogether
           struct X { /* ... */ };

[TIP] To read complex declarations, go to the right from the variable name as
      long as you can - that is, until you run into a semicolon or a closing
      right parenthesis. When you reach one of these stops, start going left
      until you reach an opening left parenthesis (or the basic type, in which
      case you're done). Each time you see a new modifier (either going right or
      left), attach it to the end of the current declaration sentence.
             int **x[5][2];
      x is an array[5] of array[2] of pointer to pointer to int

[TIP] setjmp instantiates exception handler(stop and check), longjmp raises an
      exception and jmp_buff represents exception stack. That's why:
              if (setjmp(jmp_buf) == 0) { <handle exception> }
      setjmp do kind of 'ping-pong'. Stops and transfer control to the longjmp -
      first return, second return is the result of longjmp return(it's second
      paramenter). If longjmp(jmp_buf, 1) we have to process exception.

[LANG] Set NDEBUG to disable assert().

[TIP] If a function accepts pointer to a structure this is a hint
      that this function will change the structure as side-effect.

[LANG] If you have function and macro with the same name, function
       name should be in parentheses to suppress macro expansion.

[TRICK] Use gcc -S main.c to see assembler code.

[TIP] assert to check for situations that "can't happen", e.g. that violate the
      invariants or postconditions of an algorithm, but probably not for input
      validation (certainly not in libraries). When detecting invalid input from
      clients, be friendly and return an error code.

[TIP] What asserts basically boil down to is "Why bother catching errors you
      can't handle? Just abort.". Your program logic should never reach such a
      situation.

[TIP] You can compare memory directly with memcmp because of possible different
      padding. E.g.
            typedef struct Foo {
                char a;
                /* padding(aligning) */
                double d;
                /* padding */
                char e;
            } Foo ;

[LANG] If an object that has static storage duration is not initialized
       explicitly, then:
         — if it has pointer type, it is initialized to a null pointer;
         — if it has arithmetic type, it is initialized to (positive or unsigned) zero;
         — if it is an aggregate, every member is initialized (recursively)
           according to these rules; There is no partial initialization everything
           or nothing.
         — if it is a union, the first named member is initialized (recursively)
           according to these rules.

[TIP] Stepping through a C program is less productive than thinking harder and adding
      output statements and self-checking code at critical places. Kernighan once
      wrote that the most effective debugging tool is still careful thought, coupled
      with judiciously placed print statements.

[TIP] If you dive into the bug, you tend to fix the local issue in the code, but
      if you think about the bug first, how the bug came to be, you often find and
      correct a higher-level problem in the code that will improve the design and
      prevent further bugs.

[TIP] Debuggers don’t remove bugs. They only show them in slow motion.

[LANG] C structure alignment is based on the biggest size native type in the
       structure, at least generally. Keep in mind also:
          - structures are allowed to have padding(at the end) between their members
          - arrays are not allowed to have padding between their elements

[MAKE] $@ The name of the full target name of the current target
          (the one before the colon)
       $< The name of the member of the current dependency
          (the first, next, etc. one after the colon)
       $^ The names of all the prerequisite (space separated)
          Same as previous but take all not one by one
       $* Refers to the current target name with its suffix deleted
       %  Used in target names means match anything

[MAKE] Make is a project building programming language.

[LANG] There is no issue in returning a struct. It will be passed by value.

[LANG] Since C lacks namespaces, you're left with prefixing the names of global
       functions and variables. Most libraries pick some short and "unique"
       prefix, and hope that no clashes occur.

[LANG] If you use in your library another one except .o you need its header
       file too.

[LANG] Order of header files matters.

[TIP]           ar -t build/lib/<libname>.a
      Will list object files that are part of the static library.
                nm build/lib/<libname>.a
      Show what is exported from every object file.

[TIP] Use macros if it possible to simplify complex APIs

[TIP] The utility 'ldd' examines an executable and displays a list of the shared
      libraries that it needs.

[STYLE] Even in gcc command line have to keep some convention:
            1. .h file corresponding to this .c file (if applicable)
            2. headers from the same component
            3. headers from other components
            4. system headers

[TIP] For objects, use the prefix operator(++obj) instead of the postfix operator
      (obj++) because the prefix operator does not need a temporary copy.

[TIP] If source files becomes more than ~500 lines may be it is time to divide
      it logically through many .c files.

[LANG] When d and data pointed to by d both could not be modified
             void my_func(const void* const d)

[LANG] (char *)0 is not a "pointer to a character at address 0". In C (char *)0
       is treated in a special way - it is guaranteed to produce a null-pointer
       value of type char*

[MAKE] Each line in Makefile runs in a separate shell so for example
       you can change directory without need to return.

[TIP] xs = List_tail(xs); is a way to go forward in a list.

[LANG] When a function deletes the last reference to a block of store, this
       block of store must be deallocated first.

[STYLE] The header files must be self-contained, idempotent and minimal:
          1. self-contained — all necessary types are defined by including
             relevant headers if need be.
          2. idempotent — compilations don't break even if it is included
             multiple times.
          3. minimal — it doesn't define anything that is not needed by code
             that uses the header to access the facilities defined by the header.

[GCC] In gcc, you can enable specific warnings in gcc with -Wxxxx and
      disable them with -Wno-xxxx.
